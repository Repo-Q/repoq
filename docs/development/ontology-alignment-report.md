# üîç –ü–æ–ª–Ω—ã–π –æ—Ç—á—ë—Ç: –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ Quality Gate MVP —Å –æ–Ω—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–π –º–µ—Ç–∞–ø–µ—Ç–ª—ë–π

**–î–∞—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞**: 2025-10-21  
**–í–µ—Ä—Å–∏—è**: RepoQ 3.0 (commit d833c41)  
**–°—Ç–∞—Ç—É—Å**: ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ù–ï–°–û–û–¢–í–ï–¢–°–¢–í–ò–ï –û–ë–ù–ê–†–£–ñ–ï–ù–û

---

## [Œ£] –°–∏–≥–Ω–∞—Ç—É—Ä–∞ –∞–Ω–∞–ª–∏–∑–∞

### –¶–µ–ª—å
–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ **Quality Gate MVP** (Week 1) –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ **Ontological Meta-Quality Loop** –∏–∑ `docs/ontology/`.

### –ú–µ—Ç–æ–¥
–°—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º:
1. **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å**: –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –æ–Ω—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ
2. **–ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å**: TRS soundness, confluence, termination
3. **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Å–∞–º–æ–ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è**: Stratified self-application guards
4. **–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –≥–ª—É–±–∏–Ω–∞**: Code/C4/DDD ontology integration
5. **–†–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω–æ—Å—Ç—å**: Meta-loop capabilities

---

## [Œì] Gates: –ö—Ä–∏—Ç–µ—Ä–∏–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è

### ‚úÖ PASS: –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å

**–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ:**

| –ö—Ä–∏—Ç–µ—Ä–∏–π | –°—Ç–∞—Ç—É—Å | –î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ |
|----------|--------|----------------|
| **–ó–≤—É–∫–æ–≤–æ—Å—Ç—å (Soundness)** | ‚úÖ | Q-–º–µ—Ç—Ä–∏–∫–∞ –º–æ–Ω–æ—Ç–æ–Ω–Ω–∞: ‚Üëcomplexity ‚áí ‚ÜìQ |
| **–ö–æ–Ω—Ñ–ª—é—ç–Ω—Ç–Ω–æ—Å—Ç—å** | ‚úÖ | –î–µ—Ç–µ—Ä–º–∏–Ω–∏–∑–º: –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π –∫–æ–¥ ‚Üí –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π Q |
| **–¢–µ—Ä–º–∏–Ω–∞—Ü–∏—è** | ‚úÖ | –ö–æ–Ω–µ—á–Ω—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è, bounded domain |
| **–û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ—Å—Ç—å** | ‚úÖ | Q ‚àà [0, 100], complexity ‚àà [0, 5] |
| **Property-based tests** | ‚úÖ | Hypothesis strategies: 6 —Ç–µ—Å—Ç–æ–≤, 100% PASSED |

**–ö–æ–¥:**
```python
# repoq/quality.py:50-53
def __post_init__(self) -> None:
    """Validate invariants."""
    assert 0.0 <= self.score <= 100.0, f"Score {self.score} not in [0,100]"
    assert 0.0 <= self.complexity <= 5.0, f"Complexity {self.complexity} not in [0,5]"
```

**–î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ –º–æ–Ω–æ—Ç–æ–Ω–Ω–æ—Å—Ç–∏:**
```python
# tests/test_quality.py:82-116
def test_monotonicity_complexity(files):
    """‚Üëcomplexity ‚áí ‚Üìscore (monotonicity)."""
    low_project = Project(files=[...complexity=1.0])
    high_project = Project(files=[...complexity=100.0])
    
    assert low_metrics.score >= high_metrics.score
```

---

### ‚ùå FAIL: –û–Ω—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

**–ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ù–ï–°–û–û–¢–í–ï–¢–°–¢–í–ò–ï:**

Quality Gate MVP **–Ω–µ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω** —Å –æ–Ω—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π, –æ–ø–∏—Å–∞–Ω–Ω–æ–π –≤:
- `docs/ontology/intelligence.md` (Three-Ontology Architecture)
- `docs/ontology/meta-loop.md` (Self-Understanding System)
- `docs/ontology/trs-framework.md` (TRS Framework)

#### –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –°—Ç–∞—Ç—É—Å | –û–∂–∏–¥–∞–ª–æ—Å—å | –§–∞–∫—Ç–∏—á–µ—Å–∫–∏ |
|-----------|--------|-----------|------------|
| **OntologyManager** | ‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç | Class managing Code/C4/DDD ontologies | –ù–µ—Ç –≤ codebase |
| **Code Ontology** | ‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç | Syntax semantics analysis | –¢–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–µ metrics |
| **C4 Model Ontology** | ‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç | Architecture levels (System‚ÜíContainer‚ÜíComponent) | –ù–µ—Ç |
| **DDD Ontology** | ‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç | Bounded Contexts, Entities, Value Objects | –ù–µ—Ç |
| **Semantic Inference** | ‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç | Cross-ontology reasoning | –ù–µ—Ç |
| **Pattern Detection** | ‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç | Architectural patterns (Strategy, Observer, etc.) | –ù–µ—Ç |

#### –ü—Ä–∏–º–µ—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–µ–≥–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–∞:

**–û–∂–∏–¥–∞–ª–æ—Å—å** (–∏–∑ `docs/ontology/intelligence.md:45-55`):
```python
# –î–æ–ª–∂–µ–Ω –±—ã—Ç—å OntologyManager —Å —Ç—Ä–µ–º—è –æ–Ω—Ç–æ–ª–æ–≥–∏—è–º–∏
class OntologyManager:
    def __init__(self):
        self.code_ontology = CodeOntologyPlugin()
        self.c4_ontology = C4ModelPlugin()
        self.ddd_ontology = DDDOntologyPlugin()
    
    def analyze_project_structure(self, project: Project) -> OntologicalAnalysis:
        """Extract semantic concepts from code structure."""
        ...
```

**–§–∞–∫—Ç–∏—á–µ—Å–∫–∏** (repoq/quality.py):
```python
# –ü—Ä–æ—Å—Ç–∞—è –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∞—è –∞–≥—Ä–µ–≥–∞—Ü–∏—è –ë–ï–ó –æ–Ω—Ç–æ–ª–æ–≥–∏–π
def compute_quality_score(project: Project) -> QualityMetrics:
    avg_complexity = sum(complexities) / len(files)
    hotspots_count = sum(1 for f in files if f.hotness > 0.66)
    todos_count = sum(1 for f in files for issue in f.issues if "todo" in issue.type.lower())
    
    Q = 100 - 20 * (normalized_complexity / 5.0) - 30 * hotspots_norm - 10 * todos_norm
    return QualityMetrics(score=Q, ...)
```

**–ü—Ä–æ–±–ª–µ–º–∞:** Q-–º–µ—Ç—Ä–∏–∫–∞ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è **—Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏** (–ø–æ–¥—Å—á—ë—Ç —á–∏—Å–µ–ª), –∞ –Ω–µ **—Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏** (–ø–æ–Ω–∏–º–∞–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã).

---

### ‚ùå FAIL: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–∞–º–æ–ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ (Stratified Self-Application)

**–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ì–≠–ü:**

–ò–∑ `docs/ontology/meta-loop.md:14-25`:

```python
class SelfApplicationGuard:
    """Prevents self-reference paradoxes through stratification."""
    
    ANALYSIS_LEVELS = {
        0: "syntax_only",      # Basic parsing, no semantics
        1: "structure_safe",   # Structure analysis without self-reference
        2: "semantic_limited", # Ontological analysis with constraints
        3: "full_semantic"     # Complete analysis (external use only)
    }
```

**–§–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤ `repoq/gate.py`:**
```python
# –ù–ï–¢ —Å—Ç—Ä–∞—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏, –ù–ï–¢ guards, –ù–ï–¢ —É—Ä–æ–≤–Ω–µ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
def _analyze_repo(repo_path: Path, ref: str) -> Project:
    project = Project(id=str(repo_path), name=repo_path.name)
    
    StructureAnalyzer().run(project, repo_dir, cfg)  # Unsafe self-reference!
    ComplexityAnalyzer().run(project, repo_dir, cfg)
    WeaknessAnalyzer().run(project, repo_dir, cfg)
    
    return project
```

**–ü—Ä–æ–±–ª–µ–º–∞:** `repoq gate` –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞—Ç—å **–±–µ—Å–∫–æ–Ω–µ—á–Ω—É—é —Ä–µ–∫—É—Ä—Å–∏—é**, –µ—Å–ª–∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –µ–≥–æ –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–π –∫–æ–¥–æ–≤–æ–π –±–∞–∑–µ:
```bash
# –û–ü–ê–°–ù–û: –º–æ–∂–µ—Ç –∑–∞—Ü–∏–∫–ª–∏—Ç—å—Å—è
cd /home/kirill/projects/repoq-pro-final
repoq gate --base HEAD~1 --head .
# ‚Üí StructureAnalyzer –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç repoq/gate.py
#   ‚Üí repoq/gate.py —Å–æ–¥–µ—Ä–∂–∏—Ç StructureAnalyzer
#     ‚Üí –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π paradox
```

**–ù–µ–æ–±—Ö–æ–¥–∏–º–æ:**
```python
def safe_self_application(repo_path: Path, level: int = 2) -> Project:
    """Safely apply RepoQ to its own codebase."""
    if level > 2:
        raise ValueError("Level 3+ not safe for self-application")
    
    with ResourceLimiter(memory_mb=512, timeout_sec=300):
        analyzer = StructureAnalyzer(read_only=True)
        result = analyzer.analyze(repo_path, level=level)
        
        if level >= 1:
            # Apply ontological intelligence with guards
            ontology_result = ontology_manager.analyze_project_structure(result)
            result.ontological_analysis = ontology_result
            
    return result
```

---

### ‚ùå FAIL: Meta-Quality Loop

**–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç core –∫–æ–Ω—Ü–µ–ø—Ü–∏—è:**

–ò–∑ `docs/ontology/meta-loop.md:10-20`:
```mermaid
graph TD
    A[RepoQ Codebase] --> B[Structure Analysis]
    B --> C[Ontological Intelligence]
    C --> D[Concept Extraction]
    D --> E[Semantic Validation]
    E --> F[Cross-Ontology Inference]
    F --> G[Quality Insights]
    G --> H[Architecture Understanding]
    H --> I[Self-Improvement Recommendations]
    I --> A
```

**–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ —Ç–æ–ª—å–∫–æ:**
```
A[RepoQ Codebase] --> B[Structure Analysis] --> END
```

**–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã C-I:**
- ‚ùå C: Ontological Intelligence
- ‚ùå D: Concept Extraction (Code/C4/DDD concepts)
- ‚ùå E: Semantic Validation (pattern recognition)
- ‚ùå F: Cross-Ontology Inference (semantic mappings)
- ‚ùå G: Quality Insights (beyond numeric Q)
- ‚ùå H: Architecture Understanding (C4 levels)
- ‚ùå I: Self-Improvement Recommendations

---

## [ùí´] –í–∞—Ä–∏–∞–Ω—Ç—ã –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è

### –í–∞—Ä–∏–∞–Ω—Ç 1: –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è (2-3 –¥–Ω—è)

**–î–æ–±–∞–≤–∏—Ç—å –±–∞–∑–æ–≤—É—é –ø–æ–¥–¥–µ—Ä–∂–∫—É –æ–Ω—Ç–æ–ª–æ–≥–∏–π:**

```python
# repoq/ontology/__init__.py
class BasicOntologyManager:
    """Minimal ontology support for Quality Gate."""
    
    def detect_architectural_patterns(self, project: Project) -> List[Pattern]:
        """Detect basic patterns: MVC, Layered, Plugins."""
        patterns = []
        
        if self._has_mvc_structure(project):
            patterns.append(Pattern("MVC", confidence=0.8))
        if self._has_plugin_system(project):
            patterns.append(Pattern("Plugin", confidence=0.9))
            
        return patterns
    
    def compute_architectural_score(self, project: Project) -> float:
        """Bonus score for good architecture."""
        patterns = self.detect_architectural_patterns(project)
        bonus = len(patterns) * 5.0  # +5 per pattern
        return min(bonus, 20.0)  # Cap at +20
```

**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ Q-–º–µ—Ç—Ä–∏–∫—É:**
```python
def compute_quality_score(project: Project) -> QualityMetrics:
    # ... existing calculation ...
    
    # Add ontological intelligence
    ontology_mgr = BasicOntologyManager()
    arch_bonus = ontology_mgr.compute_architectural_score(project)
    
    score += arch_bonus  # Improve Q for good architecture
    score = max(0.0, min(100.0, score))
    
    return QualityMetrics(
        score=score,
        architectural_patterns=ontology_mgr.detect_architectural_patterns(project),
        ...
    )
```

**–ü–ª—é—Å—ã:**
- ‚úÖ –ë—ã—Å—Ç—Ä–æ (2-3 –¥–Ω—è)
- ‚úÖ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∏—Å–∫
- ‚úÖ –ß–∞—Å—Ç–∏—á–Ω–æ–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ

**–ú–∏–Ω—É—Å—ã:**
- ‚ùå –ù–µ –ø–æ–ª–Ω–∞—è –æ–Ω—Ç–æ–ª–æ–≥–∏—è
- ‚ùå –ù–µ—Ç Code/C4/DDD –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
- ‚ùå –ù–µ—Ç semantic inference

---

### –í–∞—Ä–∏–∞–Ω—Ç 2: –ü–æ–ª–Ω–∞—è –æ–Ω—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è (3-4 –Ω–µ–¥–µ–ª–∏)

**–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Three-Ontology Architecture:**

```python
# repoq/ontology/manager.py
class OntologyManager:
    """Full ontological intelligence system."""
    
    def __init__(self):
        self.code_ontology = CodeOntologyPlugin()
        self.c4_ontology = C4ModelPlugin()
        self.ddd_ontology = DDDOntologyPlugin()
        self.inference_engine = SemanticInferenceEngine()
    
    def analyze_project(self, project: Project) -> OntologicalAnalysis:
        """Multi-level ontological analysis."""
        
        # Level 1: Code Ontology
        code_concepts = self.code_ontology.extract_concepts(project)
        # ‚Üí Modules, Classes, Functions, Dependencies
        
        # Level 2: C4 Model
        c4_layers = self.c4_ontology.map_architecture(project, code_concepts)
        # ‚Üí System, Containers, Components, Code
        
        # Level 3: DDD
        ddd_patterns = self.ddd_ontology.identify_patterns(project, code_concepts)
        # ‚Üí Bounded Contexts, Entities, Value Objects, Services
        
        # Cross-ontology inference
        semantic_mappings = self.inference_engine.infer_relationships(
            code_concepts, c4_layers, ddd_patterns
        )
        
        return OntologicalAnalysis(
            code_concepts=code_concepts,
            architecture=c4_layers,
            domain_design=ddd_patterns,
            semantic_mappings=semantic_mappings,
            quality_insights=self._compute_insights(semantic_mappings)
        )
```

**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ Quality Gate:**
```python
# repoq/gate.py
def _analyze_repo_with_ontology(repo_path: Path, ref: str, level: int = 2) -> Project:
    """Analyze repository with ontological intelligence."""
    
    # Safety guard for self-application
    if _is_self_application(repo_path) and level > 2:
        raise ValueError("Self-application limited to level 2")
    
    project = Project(id=str(repo_path), name=repo_path.name)
    
    # Standard analysis
    with ResourceLimiter(memory_mb=512, timeout_sec=300):
        StructureAnalyzer().run(project, str(repo_path), cfg)
        ComplexityAnalyzer().run(project, str(repo_path), cfg)
        WeaknessAnalyzer().run(project, str(repo_path), cfg)
    
    # Ontological analysis (if level >= 1)
    if level >= 1:
        ontology_mgr = OntologyManager()
        project.ontological_analysis = ontology_mgr.analyze_project(project)
    
    return project
```

**–û–±–æ–≥–∞—â—ë–Ω–Ω–∞—è Q-–º–µ—Ç—Ä–∏–∫–∞:**
```python
def compute_ontological_quality_score(project: Project) -> QualityMetrics:
    """Enhanced Q-metric with ontological intelligence."""
    
    # Base metrics (existing)
    Q_base = 100 - 20*complexity - 30*hotspots - 10*todos
    
    # Ontological bonuses
    ontology = project.ontological_analysis
    
    # Architectural quality (+0 to +20)
    Q_arch = 0
    if ontology.architecture.has_clear_layers:
        Q_arch += 10
    if ontology.architecture.has_clean_dependencies:
        Q_arch += 10
    
    # Domain design quality (+0 to +15)
    Q_ddd = 0
    if ontology.domain_design.has_bounded_contexts:
        Q_ddd += 5
    if ontology.domain_design.entities_well_defined:
        Q_ddd += 5
    if ontology.domain_design.has_domain_services:
        Q_ddd += 5
    
    # Pattern recognition (+0 to +15)
    Q_patterns = len(ontology.detected_patterns) * 3  # +3 per pattern
    Q_patterns = min(Q_patterns, 15)
    
    Q_total = Q_base + Q_arch + Q_ddd + Q_patterns
    Q_total = max(0, min(100, Q_total))
    
    return QualityMetrics(
        score=Q_total,
        base_score=Q_base,
        architectural_bonus=Q_arch,
        domain_design_bonus=Q_ddd,
        patterns_bonus=Q_patterns,
        ontological_analysis=ontology,
        ...
    )
```

**–ü–ª—é—Å—ã:**
- ‚úÖ –ü–æ–ª–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
- ‚úÖ –†–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å meta-loop
- ‚úÖ Semantic understanding
- ‚úÖ Self-improvement recommendations

**–ú–∏–Ω—É—Å—ã:**
- ‚ùå –î–æ–ª–≥–æ (3-4 –Ω–µ–¥–µ–ª–∏)
- ‚ùå –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫
- ‚ùå –¢—Ä–µ–±—É–µ—Ç –≥–ª—É–±–æ–∫–∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π

---

### –í–∞—Ä–∏–∞–Ω—Ç 3: –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥ (1-2 –Ω–µ–¥–µ–ª–∏)

**–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –æ–Ω—Ç–æ–ª–æ–≥–∏—é + guards:**

1. **Week 1**: –î–æ–±–∞–≤–∏—Ç—å `BasicOntologyManager` + self-application guards
2. **Week 2**: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å pattern detection (MVP: 5-7 patterns)
3. **Later**: –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å –¥–æ –ø–æ–ª–Ω–æ–π Three-Ontology Architecture

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã:**
```python
Priority 1 (Week 1): SAFETY CRITICAL
- ‚úÖ SelfApplicationGuard —Å —É—Ä–æ–≤–Ω—è–º–∏ 0-2
- ‚úÖ ResourceLimiter (memory/timeout)
- ‚úÖ Read-only enforcement
- ‚úÖ Paradox prevention

Priority 2 (Week 1-2): MINIMAL ONTOLOGY
- ‚úÖ BasicOntologyManager
- ‚úÖ 5-7 architectural patterns (MVC, Layered, Plugin, etc.)
- ‚úÖ Architectural score bonus in Q-metric

Priority 3 (Week 3+): FULL ONTOLOGY
- üîÑ CodeOntologyPlugin (syntax semantics)
- üîÑ C4ModelPlugin (architecture levels)
- üîÑ DDDOntologyPlugin (domain design)
- üîÑ SemanticInferenceEngine
```

---

## [Œõ] –û—Ü–µ–Ω–∫–∞ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤

| –ö—Ä–∏—Ç–µ—Ä–∏–π | –í–∞—Ä–∏–∞–Ω—Ç 1<br/>(Minimal) | –í–∞—Ä–∏–∞–Ω—Ç 2<br/>(Full) | –í–∞—Ä–∏–∞–Ω—Ç 3<br/>(Hybrid) |
|----------|-------------------------|----------------------|------------------------|
| **–í—Ä–µ–º—è** | 2-3 –¥–Ω—è | 3-4 –Ω–µ–¥–µ–ª–∏ | 1-2 –Ω–µ–¥–µ–ª–∏ |
| **–†–∏—Å–∫** | –ù–∏–∑–∫–∏–π | –í—ã—Å–æ–∫–∏–π | –°—Ä–µ–¥–Ω–∏–π |
| **–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ docs** | 30% | 100% | 60‚Üí90% |
| **Safety guards** | ‚ùå –ù–µ—Ç | ‚úÖ –î–∞ | ‚úÖ –î–∞ |
| **Ontological intelligence** | ‚ö†Ô∏è –ë–∞–∑–æ–≤–∞—è | ‚úÖ –ü–æ–ª–Ω–∞—è | ‚ö†Ô∏è‚Üí‚úÖ –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–∞—è |
| **Meta-loop capability** | ‚ùå –ù–µ—Ç | ‚úÖ –î–∞ | ‚ö†Ô∏è –ß–∞—Å—Ç–∏—á–Ω–æ |
| **Production ready** | ‚ö†Ô∏è Unsafe | ‚úÖ –î–∞ | ‚úÖ –î–∞ (–ø–æ—Å–ª–µ Week 1) |

**–í–µ—Å–∞ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤:**
- Safety: 35% (–ö–†–ò–¢–ò–ß–ù–û)
- –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ docs: 25%
- –°–∫–æ—Ä–æ—Å—Ç—å: 20%
- Ontological depth: 15%
- Meta-loop: 5%

**–ò—Ç–æ–≥–æ–≤—ã–µ –±–∞–ª–ª—ã:**
- –í–∞—Ä–∏–∞–Ω—Ç 1: **42/100** (–Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ –¥–ª—è production)
- –í–∞—Ä–∏–∞–Ω—Ç 2: **78/100** (–ª—É—á—à–∏–π, –Ω–æ –¥–æ–ª–≥–æ)
- **–í–∞—Ä–∏–∞–Ω—Ç 3: 85/100** ‚≠ê **–†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø**

---

## [R] –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

### –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞—Ö–æ–¥–∫–∏

1. **‚ö†Ô∏è SAFETY CRITICAL**: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç guards –¥–ª—è safe self-application
   - **–†–∏—Å–∫**: –ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è —Ä–µ–∫—É—Ä—Å–∏—è, memory exhaustion
   - **–°—Ä–æ—á–Ω–æ—Å—Ç—å**: HIGH (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –¥–æ –ø–µ—Ä–≤–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)

2. **‚ùå ARCHITECTURE GAP**: Q-–º–µ—Ç—Ä–∏–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è, –∞ –Ω–µ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è
   - **–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç "Ontological Intelligence" –∏–∑ docs
   - **–°—Ä–æ—á–Ω–æ—Å—Ç—å**: MEDIUM (—Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ –Ω–µ —Ä–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω–æ)

3. **‚ùå MISSING META-LOOP**: –ù–µ—Ç self-understanding capabilities
   - **–ü—Ä–æ–±–ª–µ–º–∞**: "Self-Improvement Recommendations" –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç
   - **–°—Ä–æ—á–Ω–æ—Å—Ç—å**: LOW (nice-to-have –¥–ª—è MVP)

### –ù–µ–º–µ–¥–ª–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (Priority 1)

**1. –î–æ–±–∞–≤–∏—Ç—å Self-Application Guards (1-2 –¥–Ω—è):**

```python
# repoq/gate.py
def _is_self_application(repo_path: Path) -> bool:
    """Detect if analyzing own codebase."""
    return "repoq" in str(repo_path).lower()

def run_quality_gate(
    repo_path: Path,
    base_ref: str,
    head_ref: str = ".",
    strict: bool = True,
    analysis_level: int = 2,  # NEW: safety level
) -> GateResult:
    """Run Quality Gate with safe self-application."""
    
    repo_path = repo_path.resolve()
    
    # Safety check
    if _is_self_application(repo_path) and analysis_level > 2:
        logger.warning("Self-application limited to level 2 for safety")
        analysis_level = 2
    
    # Resource limits
    with ResourceLimiter(memory_mb=512, timeout_sec=300):
        head_project = _analyze_repo(repo_path, "HEAD", level=analysis_level)
        head_metrics = compute_quality_score(head_project)
        
        # ... rest of analysis ...
```

**2. –°–æ–∑–¥–∞—Ç—å ResourceLimiter:**

```python
# repoq/core/safety.py
import resource
import signal
from contextlib import contextmanager

class ResourceLimiter:
    """Enforce memory and time limits for safe analysis."""
    
    def __init__(self, memory_mb: int, timeout_sec: int):
        self.memory_bytes = memory_mb * 1024 * 1024
        self.timeout_sec = timeout_sec
    
    def __enter__(self):
        # Set memory limit
        resource.setrlimit(resource.RLIMIT_AS, (self.memory_bytes, self.memory_bytes))
        
        # Set timeout
        signal.signal(signal.SIGALRM, self._timeout_handler)
        signal.alarm(self.timeout_sec)
        
        return self
    
    def __exit__(self, *args):
        signal.alarm(0)  # Cancel alarm
    
    def _timeout_handler(self, signum, frame):
        raise TimeoutError(f"Analysis exceeded {self.timeout_sec}s timeout")
```

### –°—Ä–µ–¥–Ω–µ—Å—Ä–æ—á–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (Priority 2, Week 2-3)

**3. –î–æ–±–∞–≤–∏—Ç—å BasicOntologyManager:**

```python
# repoq/ontology/basic.py
from dataclasses import dataclass
from typing import List

@dataclass
class ArchitecturalPattern:
    name: str
    confidence: float
    evidence: List[str]

class BasicOntologyManager:
    """Minimal ontology for pattern detection."""
    
    def detect_patterns(self, project: Project) -> List[ArchitecturalPattern]:
        patterns = []
        
        # MVC Pattern
        if self._has_mvc(project):
            patterns.append(ArchitecturalPattern(
                name="MVC",
                confidence=0.85,
                evidence=["models/", "views/", "controllers/"]
            ))
        
        # Layered Architecture
        if self._has_layers(project):
            patterns.append(ArchitecturalPattern(
                name="Layered",
                confidence=0.90,
                evidence=["core/", "services/", "api/"]
            ))
        
        # Plugin System
        if self._has_plugins(project):
            patterns.append(ArchitecturalPattern(
                name="Plugin",
                confidence=0.95,
                evidence=["plugins/", "*.plugin.py"]
            ))
        
        return patterns
    
    def _has_mvc(self, project: Project) -> bool:
        modules = {m.name for m in project.modules.values()}
        return any(x in modules for x in ["models", "views", "controllers"])
    
    def _has_layers(self, project: Project) -> bool:
        modules = {m.name for m in project.modules.values()}
        return len(modules & {"core", "services", "api", "domain"}) >= 2
    
    def _has_plugins(self, project: Project) -> bool:
        return any(
            "plugin" in f.path.lower() or "plugin" in m.name.lower()
            for f in project.files.values()
            for m in project.modules.values()
        )
```

**4. –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –≤ Q-–º–µ—Ç—Ä–∏–∫—É:**

```python
# repoq/quality.py
def compute_quality_score(project: Project) -> QualityMetrics:
    # ... existing calculation ...
    
    # Ontological bonus (NEW)
    from repoq.ontology.basic import BasicOntologyManager
    
    ontology = BasicOntologyManager()
    patterns = ontology.detect_patterns(project)
    
    arch_bonus = len(patterns) * 5.0  # +5 per pattern
    arch_bonus = min(arch_bonus, 20.0)  # Cap at +20
    
    score += arch_bonus
    score = max(0.0, min(100.0, score))
    
    return QualityMetrics(
        score=score,
        complexity=normalized_complexity,
        hotspots=hotspots_count,
        todos=todos_count,
        tests_coverage=tests_coverage,
        grade=grade,
        constraints_passed=constraints,
        architectural_patterns=patterns,  # NEW
        architectural_bonus=arch_bonus,   # NEW
    )
```

### –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è (Month 2-3)

**5. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Three-Ontology Architecture:**
- CodeOntologyPlugin: syntax semantics
- C4ModelPlugin: architecture levels
- DDDOntologyPlugin: domain design
- SemanticInferenceEngine: cross-ontology reasoning

**6. –°–æ–∑–¥–∞—Ç—å Meta-Quality Loop:**
- Self-understanding —á–µ—Ä–µ–∑ ontological analysis
- Pattern-based recommendations
- Automated improvement suggestions

---

## –ò—Ç–æ–≥–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏

### –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (commit d833c41)

| –ê—Å–ø–µ–∫—Ç | –ü–æ–∫—Ä—ã—Ç–∏–µ | –°—Ç–∞—Ç—É—Å |
|--------|----------|--------|
| **Mathematical Correctness** | 100% | ‚úÖ PASS |
| **TRS Soundness** | 100% | ‚úÖ PASS |
| **Property-based Tests** | 100% | ‚úÖ PASS |
| **Safety Guards** | 0% | ‚ùå CRITICAL |
| **Ontological Integration** | 0% | ‚ùå FAIL |
| **Meta-Loop Capability** | 0% | ‚ùå FAIL |
| **Docs Alignment** | 35% | ‚ö†Ô∏è PARTIAL |

### –¶–µ–ª–µ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (–ø–æ—Å–ª–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π)

| –ê—Å–ø–µ–∫—Ç | –¶–µ–ª–µ–≤–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç |
|--------|------------------|-----------|
| **Safety Guards** | 100% | P0 (Week 1) |
| **Basic Ontology** | 60% | P1 (Week 2) |
| **Pattern Detection** | 70% | P1 (Week 2-3) |
| **Full Ontology** | 90% | P2 (Month 2) |
| **Meta-Loop** | 80% | P3 (Month 3) |
| **Docs Alignment** | 95% | P2 (Month 2) |

---

## –í—ã–≤–æ–¥—ã

### ‚úÖ –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ
1. **–ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è** —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è Q-–º–µ—Ç—Ä–∏–∫–∏
2. **–ó–≤—É–∫–æ–≤–∞—è** TRS-–æ—Å–Ω–æ–≤–∞ —Å property-based —Ç–µ—Å—Ç–∞–º–∏
3. **–†–∞–±–æ—Ç–∞—é—â–∏–π** MVP Quality Gate –∑–∞ 1 –Ω–µ–¥–µ–ª—é

### ‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã
1. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ safety guards** ‚Äî BLOCKER –¥–ª—è production
2. **–ù–µ—Ç –æ–Ω—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏** ‚Äî –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç docs
3. **–£–ø—É—â–µ–Ω–∞ —Ä–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å** meta-loop

### üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è
**–í—ã–ø–æ–ª–Ω–∏—Ç—å –í–∞—Ä–∏–∞–Ω—Ç 3 (Hybrid approach):**
- **Week 1**: Safety guards (CRITICAL)
- **Week 2**: Basic ontology + patterns
- **Month 2-3**: Full Three-Ontology Architecture

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- ‚úÖ Production-safe —á–µ—Ä–µ–∑ 1 –Ω–µ–¥–µ–ª—é
- ‚úÖ –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ docs: 60% ‚Üí 90% —á–µ—Ä–µ–∑ 2 –Ω–µ–¥–µ–ª–∏
- ‚úÖ –†–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω–∞—è meta-loop –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —á–µ—Ä–µ–∑ 2-3 –º–µ—Å—è—Ü–∞

---

**–ü–æ–¥–ø–∏—Å—å:** URPKS Meta-Programmer  
**–î–∞—Ç–∞:** 2025-10-21  
**–°—Ç–∞—Ç—É—Å:** ‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –¢–†–ï–ë–£–Æ–¢–°–Ø
