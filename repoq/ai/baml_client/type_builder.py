# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing

from baml_py import baml_py, type_builder

# These are exports, not used here, hence the linter is disabled
from baml_py.baml_py import (  # noqa: F401 # pylint: disable=unused-import
    ClassBuilder,
    EnumBuilder,
    EnumValueBuilder,
    FieldType,
)

from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(
            classes=set(
                [
                    "CriticalPair",
                    "OntologyIssue",
                    "OntologyValidationResult",
                    "StratificationAnalysis",
                    "TRSValidationResult",
                    "TerminationProof",
                ]
            ),
            enums=set(
                [
                    "ConfluenceStatus",
                    "TerminationStatus",
                    "ValidationSeverity",
                ]
            ),
            runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
        )

    # #########################################################################
    # Generated enums 3
    # #########################################################################

    @property
    def ConfluenceStatus(self) -> "ConfluenceStatusViewer":
        return ConfluenceStatusViewer(self)

    @property
    def TerminationStatus(self) -> "TerminationStatusViewer":
        return TerminationStatusViewer(self)

    @property
    def ValidationSeverity(self) -> "ValidationSeverityViewer":
        return ValidationSeverityViewer(self)

    # #########################################################################
    # Generated classes 6
    # #########################################################################

    @property
    def CriticalPair(self) -> "CriticalPairViewer":
        return CriticalPairViewer(self)

    @property
    def OntologyIssue(self) -> "OntologyIssueViewer":
        return OntologyIssueViewer(self)

    @property
    def OntologyValidationResult(self) -> "OntologyValidationResultViewer":
        return OntologyValidationResultViewer(self)

    @property
    def StratificationAnalysis(self) -> "StratificationAnalysisViewer":
        return StratificationAnalysisViewer(self)

    @property
    def TRSValidationResult(self) -> "TRSValidationResultViewer":
        return TRSValidationResultViewer(self)

    @property
    def TerminationProof(self) -> "TerminationProofViewer":
        return TerminationProofViewer(self)


# #########################################################################
# Generated enums 3
# #########################################################################


class ConfluenceStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ConfluenceStatus")
        self._values: typing.Set[str] = set(
            [
                "CONFLUENT",
                "NON_CONFLUENT",
                "UNKNOWN",
                "LOCALLY_CONFLUENT",
            ]
        )
        self._vals = ConfluenceStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ConfluenceStatusValues":
        return self._vals


class ConfluenceStatusViewer(ConfluenceStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [
            (name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values
        ]


class ConfluenceStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def CONFLUENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONFLUENT"))

    @property
    def NON_CONFLUENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NON_CONFLUENT"))

    @property
    def UNKNOWN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("UNKNOWN"))

    @property
    def LOCALLY_CONFLUENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOCALLY_CONFLUENT"))


class TerminationStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TerminationStatus")
        self._values: typing.Set[str] = set(
            [
                "TERMINATING",
                "NON_TERMINATING",
                "UNKNOWN",
                "POTENTIALLY_DIVERGENT",
            ]
        )
        self._vals = TerminationStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TerminationStatusValues":
        return self._vals


class TerminationStatusViewer(TerminationStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [
            (name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values
        ]


class TerminationStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def TERMINATING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TERMINATING"))

    @property
    def NON_TERMINATING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NON_TERMINATING"))

    @property
    def UNKNOWN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("UNKNOWN"))

    @property
    def POTENTIALLY_DIVERGENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("POTENTIALLY_DIVERGENT"))


class ValidationSeverityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ValidationSeverity")
        self._values: typing.Set[str] = set(
            [
                "ERROR",
                "WARNING",
                "INFO",
                "SUGGESTION",
            ]
        )
        self._vals = ValidationSeverityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ValidationSeverityValues":
        return self._vals


class ValidationSeverityViewer(ValidationSeverityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [
            (name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values
        ]


class ValidationSeverityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def ERROR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ERROR"))

    @property
    def WARNING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WARNING"))

    @property
    def INFO(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INFO"))

    @property
    def SUGGESTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUGGESTION"))


# #########################################################################
# Generated classes 6
# #########################################################################


class CriticalPairAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CriticalPair")
        self._properties: typing.Set[str] = set(
            [
                "left_term",
                "right_term",
                "common_reduct",
                "joinable",
                "explanation",
            ]
        )
        self._props = CriticalPairProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CriticalPairProperties":
        return self._props


class CriticalPairViewer(CriticalPairAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [
            (name, type_builder.ClassPropertyViewer(self._bldr.property(name)))
            for name in self._properties
        ]


class CriticalPairProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def left_term(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("left_term"))

    @property
    def right_term(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("right_term"))

    @property
    def common_reduct(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("common_reduct"))

    @property
    def joinable(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("joinable"))

    @property
    def explanation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation"))


class OntologyIssueAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OntologyIssue")
        self._properties: typing.Set[str] = set(
            [
                "type",
                "location",
                "description",
                "suggested_fix",
            ]
        )
        self._props = OntologyIssueProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OntologyIssueProperties":
        return self._props


class OntologyIssueViewer(OntologyIssueAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [
            (name, type_builder.ClassPropertyViewer(self._bldr.property(name)))
            for name in self._properties
        ]


class OntologyIssueProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def location(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("location"))

    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def suggested_fix(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggested_fix"))


class OntologyValidationResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OntologyValidationResult")
        self._properties: typing.Set[str] = set(
            [
                "ontology_uri",
                "is_consistent",
                "issues",
                "reasoning_chain",
                "suggested_improvements",
                "confidence",
            ]
        )
        self._props = OntologyValidationResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OntologyValidationResultProperties":
        return self._props


class OntologyValidationResultViewer(OntologyValidationResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [
            (name, type_builder.ClassPropertyViewer(self._bldr.property(name)))
            for name in self._properties
        ]


class OntologyValidationResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def ontology_uri(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ontology_uri"))

    @property
    def is_consistent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("is_consistent"))

    @property
    def issues(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("issues"))

    @property
    def reasoning_chain(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("reasoning_chain"))

    @property
    def suggested_improvements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggested_improvements"))

    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))


class StratificationAnalysisAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StratificationAnalysis")
        self._properties: typing.Set[str] = set(
            [
                "current_level",
                "max_safe_level",
                "self_reference_detected",
                "universe_violations",
                "safe_to_proceed",
                "explanation",
            ]
        )
        self._props = StratificationAnalysisProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StratificationAnalysisProperties":
        return self._props


class StratificationAnalysisViewer(StratificationAnalysisAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [
            (name, type_builder.ClassPropertyViewer(self._bldr.property(name)))
            for name in self._properties
        ]


class StratificationAnalysisProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def current_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("current_level"))

    @property
    def max_safe_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("max_safe_level"))

    @property
    def self_reference_detected(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("self_reference_detected"))

    @property
    def universe_violations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("universe_violations"))

    @property
    def safe_to_proceed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("safe_to_proceed"))

    @property
    def explanation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation"))


class TRSValidationResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TRSValidationResult")
        self._properties: typing.Set[str] = set(
            [
                "rule_id",
                "confluence_status",
                "termination_status",
                "critical_pairs",
                "termination_proof",
                "issues",
                "suggestions",
                "confidence",
            ]
        )
        self._props = TRSValidationResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TRSValidationResultProperties":
        return self._props


class TRSValidationResultViewer(TRSValidationResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [
            (name, type_builder.ClassPropertyViewer(self._bldr.property(name)))
            for name in self._properties
        ]


class TRSValidationResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def rule_id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rule_id"))

    @property
    def confluence_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confluence_status"))

    @property
    def termination_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("termination_status"))

    @property
    def critical_pairs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("critical_pairs"))

    @property
    def termination_proof(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("termination_proof"))

    @property
    def issues(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("issues"))

    @property
    def suggestions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestions"))

    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))


class TerminationProofAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb  # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TerminationProof")
        self._properties: typing.Set[str] = set(
            [
                "method",
                "measure",
                "well_founded",
                "explanation",
            ]
        )
        self._props = TerminationProofProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TerminationProofProperties":
        return self._props


class TerminationProofViewer(TerminationProofAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [
            (name, type_builder.ClassPropertyViewer(self._bldr.property(name)))
            for name in self._properties
        ]


class TerminationProofProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties  # type: ignore (we know how to use this private attribute) # noqa: F821

    @property
    def method(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("method"))

    @property
    def measure(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("measure"))

    @property
    def well_founded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("well_founded"))

    @property
    def explanation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation"))
