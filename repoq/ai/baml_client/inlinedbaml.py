# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "generators.baml": "// BAML Generators Configuration\n// Defines how to generate Python client code\n\ngenerator target {\n  output_type \"python/pydantic\"\n  output_dir \"../\"\n  version \"0.211.2\"\n}\n",
    "main.baml": "// BAML AI Agent for RepoQ\n// Phase 5.8: AI-Assisted TRS/Ontology Validation\n// Version: 1.0.0\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// CLIENT CONFIGURATION\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nclient<llm> GPT4 {\n  provider \"openai\"\n  options {\n    model \"gpt-4-turbo-preview\"\n    api_key env.OPENAI_API_KEY\n    temperature 0.1  // Low temperature for deterministic reasoning\n    max_tokens 4000\n  }\n}\n\nclient<llm> GPT4Mini {\n  provider \"openai\"\n  options {\n    model \"gpt-4o-mini\"\n    api_key env.OPENAI_API_KEY\n    temperature 0.1\n    max_tokens 2000\n  }\n}\n\nclient<llm> Claude {\n  provider \"anthropic\"\n  options {\n    model \"claude-3-5-sonnet-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n    temperature 0.1\n    max_tokens 4000\n  }\n}\n\n// Fallback chain: GPT-4 → Claude → GPT-4-mini\nclient<llm> ProductionAgent {\n  provider \"fallback\"\n  options {\n    strategy [GPT4, Claude, GPT4Mini]\n  }\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// DATA TYPES\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nenum ConfluenceStatus {\n  CONFLUENT\n  NON_CONFLUENT\n  UNKNOWN\n  LOCALLY_CONFLUENT\n}\n\nenum TerminationStatus {\n  TERMINATING\n  NON_TERMINATING\n  UNKNOWN\n  POTENTIALLY_DIVERGENT\n}\n\nenum ValidationSeverity {\n  ERROR      // Blocks merge\n  WARNING    // Requires review\n  INFO       // Informational\n  SUGGESTION // Optional improvement\n}\n\nclass CriticalPair {\n  left_term string\n  right_term string\n  common_reduct string?\n  joinable bool\n  explanation string\n}\n\nclass TerminationProof {\n  method string  // \"polynomial_interpretation\" | \"lexicographic_path_order\" | \"dependency_pairs\"\n  measure string?\n  well_founded bool\n  explanation string\n}\n\nclass OntologyIssue {\n  type string  // \"inconsistency\" | \"redundancy\" | \"missing_axiom\" | \"invalid_property\"\n  location string\n  description string\n  suggested_fix string?\n}\n\nclass TRSValidationResult {\n  rule_id string\n  confluence_status ConfluenceStatus\n  termination_status TerminationStatus\n  critical_pairs CriticalPair[]\n  termination_proof TerminationProof?\n  issues string[]\n  suggestions string[]\n  confidence float  // 0.0-1.0\n}\n\nclass OntologyValidationResult {\n  ontology_uri string\n  is_consistent bool\n  issues OntologyIssue[]\n  reasoning_chain string[]\n  suggested_improvements string[]\n  confidence float\n}\n\nclass StratificationAnalysis {\n  current_level int\n  max_safe_level int\n  self_reference_detected bool\n  universe_violations string[]\n  safe_to_proceed bool\n  explanation string\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// FUNCTIONS - TRS VALIDATION\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nfunction ValidateTRSRule(\n  rule_lhs: string,\n  rule_rhs: string,\n  existing_rules: string[],\n  context: string\n) -> TRSValidationResult {\n  client ProductionAgent\n  \n  prompt #\"\n    You are a formal methods expert specializing in Term Rewriting Systems (TRS).\n    Analyze the following TRS rule for soundness and mathematical correctness.\n    \n    ## Rule to Validate\n    {{ rule_lhs }} → {{ rule_rhs }}\n    \n    ## Existing Rules (Context)\n    {% for rule in existing_rules %}\n    - {{ rule }}\n    {% endfor %}\n    \n    ## Additional Context\n    {{ context }}\n    \n    ## Analysis Tasks\n    \n    1. **Confluence Check:**\n       - Compute critical pairs with existing rules\n       - Determine if all critical pairs are joinable\n       - Use Newman's Lemma if termination is proven\n    \n    2. **Termination Check:**\n       - Apply polynomial interpretation if possible\n       - Try lexicographic path order (LPO)\n       - Check for recursive calls and measure functions\n    \n    3. **Soundness:**\n       - Verify rule preserves type correctness\n       - Check for variable capture issues\n       - Validate preconditions\n    \n    {{ ctx.output_format }}\n    \n    Be precise and cite specific theorems (Newman, Church-Rosser, etc.).\n  \"#\n}\n\nfunction CheckCriticalPairs(\n  rule1: string,\n  rule2: string,\n  overlap_analysis: string\n) -> CriticalPair[] {\n  client ProductionAgent\n  \n  prompt #\"\n    Compute critical pairs between two TRS rules.\n    \n    ## Rule 1\n    {{ rule1 }}\n    \n    ## Rule 2\n    {{ rule2 }}\n    \n    ## Overlap Analysis\n    {{ overlap_analysis }}\n    \n    ## Task\n    1. Find all non-trivial overlaps\n    2. For each overlap, compute the critical pair (left, right)\n    3. Attempt to join the pair (find common reduct)\n    4. Explain joinability\n    \n    {{ ctx.output_format }}\n  \"#\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// FUNCTIONS - ONTOLOGY VALIDATION\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nfunction ValidateOntology(\n  ontology_turtle: string,\n  ontology_context: string,\n  shacl_shapes: string?\n) -> OntologyValidationResult {\n  client ProductionAgent\n  \n  prompt #\"\n    You are a semantic web and ontology engineering expert.\n    Validate the following RDF/OWL ontology for consistency and best practices.\n    \n    ## Ontology (Turtle Format)\n    ```turtle\n    {{ ontology_turtle }}\n    ```\n    \n    ## Context\n    {{ ontology_context }}\n    \n    {% if shacl_shapes %}\n    ## SHACL Constraints\n    ```turtle\n    {{ shacl_shapes }}\n    ```\n    {% endif %}\n    \n    ## Validation Tasks\n    \n    1. **Consistency Check:**\n       - Check for contradictory axioms\n       - Verify class hierarchy (no cycles)\n       - Validate property domains/ranges\n    \n    2. **Completeness:**\n       - Identify missing axioms\n       - Check for undefined references\n       - Suggest additional constraints\n    \n    3. **Best Practices:**\n       - Use of standard vocabularies (SKOS, DCMI, etc.)\n       - Proper use of owl:imports\n       - Documentation (rdfs:label, rdfs:comment)\n    \n    4. **SHACL Compliance:**\n       - Validate against provided shapes\n       - Report violations\n    \n    {{ ctx.output_format }}\n  \"#\n}\n\nfunction AnalyzeStratification(\n  current_code: string,\n  meta_operations: string[],\n  self_analysis_depth: int\n) -> StratificationAnalysis {\n  client ProductionAgent\n  \n  prompt #\"\n    You are a type theory and meta-programming expert.\n    Analyze code for stratification safety (Russell's Paradox prevention).\n    \n    ## Current Code\n    ```python\n    {{ current_code }}\n    ```\n    \n    ## Meta-Operations Detected\n    {% for op in meta_operations %}\n    - {{ op }}\n    {% endfor %}\n    \n    ## Current Self-Analysis Depth\n    {{ self_analysis_depth }}\n    \n    ## Analysis Tasks\n    \n    1. **Universe Level Analysis:**\n       - Identify universe levels (Type₀, Type₁, etc.)\n       - Check for self-reference (x : x, x ∈ x)\n       - Verify quote/unquote stratification\n    \n    2. **Safety Verification:**\n       - Apply Theorem F (Feferman): quote(X) ∈ Type_{n+1} if X ∈ Type_n\n       - Check max_level constraint\n       - Verify self_analysis_max_level not exceeded\n    \n    3. **Paradox Detection:**\n       - Look for Curry's paradox patterns\n       - Check for impredicative definitions\n       - Verify Girard's Rule (no Type : Type)\n    \n    {{ ctx.output_format }}\n  \"#\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// FUNCTIONS - CODE REVIEW ASSISTANCE\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nfunction ReviewPullRequest(\n  diff: string,\n  file_paths: string[],\n  pr_description: string,\n  quality_policy: string\n) -> ValidationSeverity {\n  client ProductionAgent\n  \n  prompt #\"\n    You are a RepoQ quality gate reviewer.\n    Review the following pull request for compliance with quality policy.\n    \n    ## Diff\n    ```diff\n    {{ diff }}\n    ```\n    \n    ## Files Changed\n    {% for path in file_paths %}\n    - {{ path }}\n    {% endfor %}\n    \n    ## PR Description\n    {{ pr_description }}\n    \n    ## Quality Policy\n    ```yaml\n    {{ quality_policy }}\n    ```\n    \n    ## Review Checklist\n    \n    1. **TRS Changes:**\n       - If TRS rules modified, validate confluence\n       - Check termination proofs\n       - Verify no breaking changes\n    \n    2. **Ontology Changes:**\n       - Validate consistency\n       - Check for breaking changes in schema\n       - Verify backward compatibility\n    \n    3. **Code Quality:**\n       - Test coverage impact\n       - Complexity metrics\n       - Documentation completeness\n    \n    4. **Stratification:**\n       - Check self-analysis depth\n       - Verify universe levels\n       - No paradox patterns\n    \n    {{ ctx.output_format }}\n    \n    Return severity level:\n    - ERROR: Blocks merge (critical issues)\n    - WARNING: Requires human review\n    - INFO: Informational only\n    - SUGGESTION: Optional improvements\n  \"#\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// TESTING - See tests/test_baml_agent.py for test cases\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n// Test cases include:\n// 1. ValidateTRSRule: Non-confluent rule detection\n// 2. AnalyzeStratification: Unsafe self-reference detection\n// 3. ValidateOntology: Inconsistency detection (disjoint classes)\n",
}

def get_baml_files():
    return _file_map